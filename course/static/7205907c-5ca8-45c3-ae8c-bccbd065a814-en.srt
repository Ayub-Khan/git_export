0
00:00:00,820 --> 00:00:03,210
JOHN GUTTAG: Hello, it's me again.

1
00:00:03,210 --> 00:00:06,610
In the last segment, we looked at hashing and hash tables by drawing a

2
00:00:06,610 --> 00:00:08,260
bunch of pictures.

3
00:00:08,260 --> 00:00:11,050
Now it's time to look at some code.

4
00:00:11,050 --> 00:00:14,850
The class intDict uses a simple hash function, the same we looked at

5
00:00:14,850 --> 00:00:19,960
before, modulus, to implement a dictionary with integers as keys.

6
00:00:19,960 --> 00:00:23,790
I know that's boring because we could just use a list, but it's at least

7
00:00:23,790 --> 00:00:25,730
easy to understand.

8
00:00:25,730 --> 00:00:29,580
The basic idea is the same when we looked at in the last segment.

9
00:00:29,580 --> 00:00:34,090
You represent instances of class intDict by a list of buckets where

10
00:00:34,090 --> 00:00:37,800
each bucket is a list of key value tuples.

11
00:00:37,800 --> 00:00:41,940
By making each bucket a list, you will recall, we handle collisions by

12
00:00:41,940 --> 00:00:46,330
storing all the values that hash to that bucket.

13
00:00:46,330 --> 00:00:49,770
By the way, there are many other ways to handle collisions, some

14
00:00:49,770 --> 00:00:51,975
considerably better than using lists.

15
00:00:51,975 --> 00:00:54,380
But this is probably the simplest mechanism.

16
00:00:54,380 --> 00:00:58,000
And it works fine if the hash table is big enough, and the hash function

17
00:00:58,000 --> 00:01:02,390
provides a good enough approximation to a uniform distribution.

18
00:01:02,390 --> 00:01:05,680
All right, to the code.

19
00:01:05,680 --> 00:01:08,320
So we've got class intDict.

20
00:01:08,320 --> 00:01:11,820
Init does exactly what we looked at in the last segment.

21
00:01:11,820 --> 00:01:15,800
It takes the number of buckets as an argument, and then creates an empty

22
00:01:15,800 --> 00:01:21,040
dictionary, and then goes through and adds to each dictionary a bucket,

23
00:01:21,040 --> 00:01:25,130
which is initialized to be the empty list.

24
00:01:25,130 --> 00:01:29,100
Exactly what we saw in the picture in the last segment.

25
00:01:29,100 --> 00:01:32,410
addEntry entry, takes the key and the value.

26
00:01:32,410 --> 00:01:35,280
It starts by finding the correct bucket.

27
00:01:35,280 --> 00:01:39,440
It does that by taking the key and then hashing using modulus.

28
00:01:39,440 --> 00:01:43,920
And it gets the number to take it from self.numBuckets.

29
00:01:43,920 --> 00:01:50,620
If we go back, we'll see that we saved numBuckets as an attribute of the hash

30
00:01:50,620 --> 00:01:52,460
table being created.

31
00:01:52,460 --> 00:01:56,410
Consequently, we can retrieve it here and use it.

32
00:01:56,410 --> 00:02:00,460
It's then going to go look at the hash bucket, as we did in the last segment,

33
00:02:00,460 --> 00:02:02,950
until it finds the dictionary key.

34
00:02:02,950 --> 00:02:06,660
If it does, it updates it and then returns.

35
00:02:06,660 --> 00:02:08,830
Notice that once it's returned, it's done.

36
00:02:08,830 --> 00:02:11,460
It never gets to this statement if it returns.

37
00:02:11,460 --> 00:02:16,650
On the other hand, if it finishes this loop without finding the key, then it

38
00:02:16,650 --> 00:02:23,090
just adds a new tuple dictKey, dictVal to the dictionary.

39
00:02:23,090 --> 00:02:27,530
getValue is very similar to addEntry , a little bit simpler.

40
00:02:27,530 --> 00:02:30,440
Once again, it has to start by finding the bucket, which it

41
00:02:30,440 --> 00:02:31,800
does the same way.

42
00:02:31,800 --> 00:02:36,070
Once again, it has to search through the bucket, looking at each element,

43
00:02:36,070 --> 00:02:38,540
to see if it can match the key.

44
00:02:38,540 --> 00:02:43,270
If it finds a match, it returns the value associated with that key.

45
00:02:43,270 --> 00:02:46,920
Otherwise, it didn't find the match, then it returns None.

46
00:02:46,920 --> 00:02:50,710
I suppose it would have been perhaps better to raise an exception, but I'm

47
00:02:50,710 --> 00:02:52,920
sure you get the idea.

48
00:02:52,920 --> 00:02:55,910
Let's now go look at the code window.

49
00:02:55,910 --> 00:03:00,480
Way down at the bottom I've got one extra method we didn't look at.

50
00:03:00,480 --> 00:03:02,090
That's the string method.

51
00:03:02,090 --> 00:03:06,570
And it does nothing interesting, it just provides a way to print it.

52
00:03:06,570 --> 00:03:09,752
Now let's see what happens if we use it.

53
00:03:09,752 --> 00:03:11,570
It does nothing very interesting.

54
00:03:11,570 --> 00:03:15,290
It creates a dictionary with 29 entries.

55
00:03:15,290 --> 00:03:19,810
And then I'm going to, for i in range 20, that's going to be a number of

56
00:03:19,810 --> 00:03:26,080
inserts, I'm going to choose a random integer in the range up to 10^5 --

57
00:03:26,080 --> 00:03:28,410
so quite a large range of numbers.

58
00:03:28,410 --> 00:03:33,120
That will be my key, and then I'll add that key with i, the i-th

59
00:03:33,120 --> 00:03:35,280
insertion as the entry.

60
00:03:35,280 --> 00:03:38,130
Then after we've built it, we want to look at what's in there.

61
00:03:38,130 --> 00:03:41,790
In order to make it a little easier to see, I'm going to print it bucket by

62
00:03:41,790 --> 00:03:44,400
bucket so that we can see the buckets.

63
00:03:44,400 --> 00:03:47,010
But of course, that violates the abstraction barrier.

64
00:03:47,010 --> 00:03:51,150
I really shouldn't be doing that, in a good program.

65
00:03:51,150 --> 00:03:54,350
But for pedagogical reasons, it's worth doing.

66
00:03:54,350 --> 00:03:59,150
So let's run it and see what we get.

67
00:03:59,150 --> 00:04:03,240
Well, we get 29 buckets which, conveniently, just happens to fit on

68
00:04:03,240 --> 00:04:04,510
our screen.

69
00:04:04,510 --> 00:04:08,880
If we look at it, we'll see that some buckets, like the first one here, have

70
00:04:08,880 --> 00:04:10,790
just one element in them.

71
00:04:10,790 --> 00:04:15,720
Other buckets have multiple elements because there's been a collision.

72
00:04:15,720 --> 00:04:18,279
And a lot of the buckets are empty.

73
00:04:18,279 --> 00:04:22,590
But again, observe, even though the keys can get very large, I don't have

74
00:04:22,590 --> 00:04:28,160
very many collisions as we're inserting 20 elements into 29 buckets.

75
00:04:28,160 --> 00:04:32,290
Now let's return to the code for getValue.

76
00:04:32,290 --> 00:04:34,830
What is it's algorithmic complexity?

77
00:04:34,830 --> 00:04:36,370
Well, let's look at the simple case.

78
00:04:36,370 --> 00:04:39,010
If there were no collisions, what would happen?

79
00:04:39,010 --> 00:04:41,720
We'd go through this loop exactly once.

80
00:04:41,720 --> 00:04:44,450
And so it would be order one.

81
00:04:44,450 --> 00:04:46,500
Suppose there's a collision.

82
00:04:46,500 --> 00:04:50,730
Well, as we saw last time, if there's a collision, it has to go down the

83
00:04:50,730 --> 00:04:54,490
entire length of the list in the bucket.

84
00:04:54,490 --> 00:04:58,910
Let's think of the simple case where we got very unlucky, and everything

85
00:04:58,910 --> 00:05:01,080
hashed to the same bucket.

86
00:05:01,080 --> 00:05:06,990
Well, if we inserted n elements and each hashed to the same bucket, then

87
00:05:06,990 --> 00:05:11,750
we would have to do order n trips through this loop to see whether or

88
00:05:11,750 --> 00:05:13,590
not we had an entry.

89
00:05:13,590 --> 00:05:17,740
But remember, we decided that our hash function was uniform, or we would

90
00:05:17,740 --> 00:05:22,200
design it to be uniform, and therefore it's unlikely that everything would

91
00:05:22,200 --> 00:05:24,100
hash to the same bucket.

92
00:05:24,100 --> 00:05:28,680
In fact, let's think about what the actual predicted time should be.

93
00:05:28,680 --> 00:05:35,470
Let's assume that we have k buckets and n insertions.

94
00:05:35,470 --> 00:05:38,360
And again, let's assume the hash is uniform.

95
00:05:38,360 --> 00:05:41,270
What is the average length of a bucket?

96
00:05:41,270 --> 00:05:46,550
It's simply the number of insertions divided by the number of buckets

97
00:05:46,550 --> 00:05:49,810
This wraps up our brief excursion into hashing.

98
00:05:49,810 --> 00:05:53,170
There are a small number of things to take away.

99
00:05:53,170 --> 00:05:58,570
One, and this is probably the most important thing to remember, hash

100
00:05:58,570 --> 00:06:05,260
tables are really useful, especially if you want to optimize the time

101
00:06:05,260 --> 00:06:08,300
required to look up keys other than integers.

102
00:06:08,300 --> 00:06:13,080
If the key is an integer, a list works just fine.

103
00:06:13,080 --> 00:06:19,870
Two, it's very important, as we've said perhaps too many times for your

104
00:06:19,870 --> 00:06:26,680
taste, for the hash function to provide a uniform distribution.

105
00:06:26,680 --> 00:06:29,530
Otherwise, we get too many collisions.

106
00:06:29,530 --> 00:06:33,730
And finally, a hash table is an example of a data structure that

107
00:06:33,730 --> 00:06:37,830
allows us to trade time for space.

108
00:06:37,830 --> 00:06:40,910
By using more space, we can use less time.

